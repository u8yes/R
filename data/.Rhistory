main="Fiji Earthquakes(magnitude)",
ylab = "latitude", xlab = "longitude",
pch="@", col="blue")
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# (2) 지진의 깊이를 5개 영역으로 범주화
depthgroup <- equal.count(quakes$depth, number=5, overlap=0) # overlap - 겹쳐지지 않게 하라
depthgroup
# 범주화된 변수(depthgroup)를 조건으로 산점도 그래프 그리기
xyplot(lat~long | depthgroup, data = quakes,
main="Fiji Earthquakes(depthgroup)",
ylab="위도", xlab="경도",pch="@", col="red")
# 수심과 리히터규모 변수를 동시에 적용하여 산점도 그래프 그리기
magnitudegroup <- equal.count(quakes$mag, number=2, overlap=0)
magnitudegroup
# magnitudegroup 변수 기준으로 플로팅
xyplot(lat~long | magnitudegroup, data = quakes,
main="Fiji Earthquakes(magnitude)",
ylab = "latitude", xlab = "longitude",
pch="@", col="blue")
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="야야", col=c("red", "blue"))
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="안녕하세요", col=c("red", "blue"))
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="굿", col=c("red", "blue"))
# magnitudegroup 변수 기준으로 플로팅
xyplot(lat~long | magnitudegroup, data = quakes,
main="Fiji Earthquakes(magnitude)",
ylab = "latitude", xlab = "longitude",
pch="@", col="blue")
# 수심과 리히터 규모를 동시에 표현(2행 5열 패널 구조)
xyplot(lat~long | depthgroup*magnitudegroup, data=quakes,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="굿", col=c("red", "blue"))
# depth 변수 리코딩분
quakes$depth3[quakes$depth >= 39.5 & quakes$depth <= 80.5] <- 'd1'
quakes$depth3[quakes$depth >= 79.5 & quakes$depth <= 186.5] <- 'd2'
quakes$depth3[quakes$depth >= 185.5 & quakes$depth <= 397.5] <- 'd3'
quakes$depth3[quakes$depth >= 396.5 & quakes$depth <= 562.5] <- 'd4'
quakes$depth3[quakes$depth >= 562.5 & quakes$depth <= 680.5] <- 'd5'
# mag 변수 리코딩
quakes$mag3[quakes$mag >= 3.95 & quakes$mag <= 4.65] <- 'm1'
quakes$mag3[quakes$mag >= 4.55 & quakes$mag <= 6.45] <- 'm2'
View(quakes)
str(quakes)
convert <- transform(quakes, depth3=factor(depth3), mag3=factor(mag3))
str(convert)
xyplot(lat ~ long | depth3*mag3, data=convert,
main="Fiji Earthquakes",
ylab = "latitude", xlab = "longitude",
pch="@", col=c("red", "blue"))
coplot(lat~long | depth, data = quakes, number = 5, row = 1) # 사이간격 5, 1행 5열
# 2.7 조건 그래프(graphics 패키지에서 제공)
coplot(lat~long | depth, data = quakes) # default:6개영역, 0.5단위로 겹침.
coplot(lat~long | depth, data = quakes, overlap = 0.1) # 겹치는 구간:0.1
coplot(lat~long | depth, data = quakes, number = 5, row = 1) # 사이간격 5, 1행 5열
# 2.7 조건 그래프(graphics 패키지에서 제공)
coplot(lat~long | depth, data = quakes) # default:6개영역, 0.5단위로 겹침.
coplot(lat~long | depth, data = quakes, overlap = 0.1) # 겹치는 구간:0.1
coplot(lat~long | depth, data = quakes, number = 5, row = 1) # 사이간격 5, 1행 5열
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
coplot(lat~long | depth, data = quakes, number = 5, row=1,
col="blue", bar.bg = c(num="green")) # 패널과 조건 막대 색
help(coplot)
# 패널과 조건 막대에 색 적용 후 조건 그래프 그리기
coplot(lat~long | depth, data = quakes, number = 5, row=1,
panel=panel.smooth)
help(coplot)
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
# 테두리와 회전 속성을 추가하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
panel.aspect=0.9,
screen=list(z=45, x=-25),
xlab = "경도", ylab = "위도", zlab = "깊이") # panel.aspect:테두리사이즈, screen : 회전각
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
# 테두리와 회전 속성을 추가하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
panel.aspect=0.9,
screen=list(z=45, x=-25),
xlab = "경도", ylab = "위도", zlab = "깊이") # panel.aspect:테두리사이즈, screen : 회전각
# 위도, 경도, 깊이를 이용하여 3차원 산점도 그래프 그리기
cloud(depth ~ lat * long, data = quakes,
zlim = rev(range(quakes$depth)),
xlab = "경도", ylab = "위도", zlab = "깊이")
install.packages("ggplot2")
library(ggplot2)
data("mpg")
View(mpg)
str(mpg)
class(mpg)
summary(mpg)
# (1) 한 개 변수 대상 qplot() 함수 적용
help(qplot)
qplot(data=mpg, x=hwy) # 세로 막대 그래프
str(mpg)
class(mpg)
summary(mpg)
qplot(data=mpg, x=hwy) # 세로 막대 그래프
# fill 속성: hwy 변수를 대상으로 drv 변수에 색 채우기(누적 막대 그래프)
qplot(hwy, data=mpg, fill=drv) # fill 옵션 적용
# binwidth 속성: 막대 폭 지정 옵션
qplot(hwy, data=mpg, fill=drv, binwidth=2) # binwidth 옵션 적용(막대의 폭 크기 지정)
# facets 속성:drv 변수 값으로 컬럼 단위와 행 단위로 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = .~ drv, binwidth=2) # 열 단위 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = drv ~. , binwidth=2) # 행 단위 패널 생성
# (2) 두 개 변수 대상 qplot() 함수 적용.
qplot(displ, hwy, data=mpg) # mpg 데이터 셋의 displ과 hwy 변수 이용(산점도).
# displ, hwy 대상으로 drv 변수값으로 색상 적용 산점도 그래프
qplot(displ, hwy, data=mpg, color=drv)
# displ과 hwy 변수와 관계를 drv로 구분
qplot(displ, hwy, data=mpg, color=drv, facets=.~drv)
View(mtcars)
# (1) 한 개 변수 대상 qplot() 함수 적용
help(qplot)
class(mpg)
summary(mpg)
qplot(data=mpg, x=hwy) # 세로 막대 그래프
qplot(data=mpg, x=hwy) # 세로 막대 그래프
# fill 속성: hwy 변수를 대상으로 drv 변수에 색 채우기(누적 막대 그래프)
qplot(hwy, data=mpg, fill=drv) # fill 옵션 적용
# binwidth 속성: 막대 폭 지정 옵션
qplot(hwy, data=mpg, fill=drv, binwidth=2) # binwidth 옵션 적용(막대의 폭 크기 지정)
str(mpg)
# (1) 한 개 변수 대상 qplot() 함수 적용
help(qplot)
qplot(data=mpg, x=hwy) # 세로 막대 그래프
install.packages("ggplot2") # 필수 패키지(ggplot, lattice 등)
library(ggplot2)
data("mpg")
View(mpg)
str(mpg) # 234 obs. of  11 variables:
class(mpg) # "data.frame"
summary(mpg)
# (1) 한 개 변수 대상 qplot() 함수 적용
help(qplot)
qplot(data=mpg, x=hwy) # 세로 막대 그래프
# fill 속성: hwy 변수를 대상으로 drv 변수에 색 채우기(누적 막대 그래프)
qplot(hwy, data=mpg, fill=drv) # fill 옵션 적용
# facets 속성:drv 변수 값으로 컬럼 단위와 행 단위로 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = .~ drv, binwidth=2) # 열 단위 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = drv ~. , binwidth=2) # 행 단위 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = drv ~. , binwidth=2) # 행 단위 패널 생성
# facets 속성:drv 변수 값으로 컬럼 단위와 행 단위로 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = .~ drv, binwidth=2) # 열 단위 패널 생성
qplot(hwy, data=mpg, fill=drv, facets = drv ~. , binwidth=2) # 행 단위 패널 생성
# (2) 두 개 변수 대상 qplot() 함수 적용.
qplot(displ, hwy, data=mpg) # mpg 데이터 셋의 displ과 hwy 변수 이용(산점도).
# displ, hwy 대상으로 drv 변수값으로 색상 적용 산점도 그래프
qplot(displ, hwy, data=mpg, color=drv)
# displ과 hwy 변수와 관계를 drv로 구분
qplot(displ, hwy, data=mpg, color=drv, facets=.~drv)
# displ과 hwy 변수와 관계를 drv로 구분
qplot(displ, hwy, data=mpg, color=drv, facets=.~drv)
View(mpg)
View(mtcars)
str(mtcars) # 'data.frame':	32 obs. of  11 variables:
table(mtcars$carb)
# 1  2  3  4  6  8
# 7 10  3 10  1  1
table(mtcars$cyl)
qplot(wt,mpg,data=mtcars)
qplot(wt,mpg,data=mtcars) # 1개(wt)이면 막대 형태, 2개(mpg)이면 점의 형태
qplot(wt,mpg,data=mtcars,color=factor(carb)) # 색상 적용
qplot(wt,mpg,data=mtcars,color=factor(carb),size=qsec) # 크기 적용
qplot(wt,mpg,data=mtcars,color=factor(carb),size=qsec, shape=factor(cyl)) # 모양 적용
qplot(wt,mpg,data=mtcars) # 1개(wt)이면 막대 형태, 2개(mpg)이면 점의 형태
qplot(wt,mpg,data=mtcars,color=factor(carb)) # 색상 적용
qplot(wt,mpg,data=mtcars,color=factor(carb),size=qsec) # 크기 적용
qplot(wt,mpg,data=mtcars,color=factor(carb),size=qsec, shape=factor(cyl)) # 모양 적용
qplot(wt,mpg,data=mtcars,color=factor(carb)) # 색상 적용
#  4  6  8
# 11  7 14
help(mtcars)
qplot(wt,mpg,data=mtcars,color=factor(carb),size=qsec) # 크기 적용
qplot(wt,mpg,data=mtcars,color=factor(carb),size=qsec, shape=factor(cyl)) # 모양 적용
# (4) 기하학적 객체 적용
View(diamonds)
# geom="bar"(속성으로 막대그래프 그리기)
# -> clarity 변수 대상 cut 변수로 색 채우기
qplot(clarity,data=diamonds,fill=cut, geom="bar")# 레이아웃에 색 채우기
qplot(clarity,data=diamonds,color=cut, geom="bar") # 테두리 적용.
# geom="bar"(속성으로 막대그래프 그리기)
# -> clarity 변수 대상 cut 변수로 색 채우기
qplot(clarity,data=diamonds,fill=cut, geom="bar")# 레이아웃에 색 채우기
# geom="point"
qplot(wt,mpg,data=mtcars,size=qsec, geom="point")
qplot(clarity,data=diamonds,color=cut, geom="bar") # 테두리 적용.
# geom="point"
qplot(wt,mpg,data=mtcars,size=qsec, geom="point")
# cyl 변수의 요인으로 point 크기 적용, carb 변수의 요인으로 포인트 색 적용.
qplot(wt,mpg,data=mtcars,size=factor(cyl),color=factor(carb), geom="point")
# cyl 변수의 요인으로 point 크기 적용, carb 변수의 요인으로 포인트 색 적용.
qplot(wt,mpg,data=mtcars,size=factor(cyl),color=factor(carb), geom="point")
# qsec 변수로 포인트 크기 적용, cyl 변수의 요인으로 point 모양 적용.
qplot(wt,mpg,data=mtcars,size=qsec,color=factor(carb),shape=factor(cyl),geom = "point" )
# geom="smooth"
qplot(wt,mpg,data=mtcars,geom=c("point","smooth"))
qplot(wt,mpg,data=mtcars,color=factor(cyl),geom=c("point","smooth")) # cyl 변수 요인으로 색상 적용.
# qsec 변수로 포인트 크기 적용, cyl 변수의 요인으로 point 모양 적용.
qplot(wt,mpg,data=mtcars,size=qsec,color=factor(carb),shape=factor(cyl),geom = "point" )
# geom="smooth"
qplot(wt,mpg,data=mtcars,geom=c("point","smooth"))
qplot(wt,mpg,data=mtcars,color=factor(cyl),geom=c("point","smooth")) # cyl 변수 요인으로 색상 적용.
# geom="line"
qplot(mpg,wt,data=mtcars,color=factor(cyl),geom="line")
qplot(mpg,wt,data=mtcars,color=factor(cyl),geom=c("point","line"))
# 단계1(layer1): 배경 설정하기.
# x축은 displ, y축은 hwy로 지정해 배경 생성
ggplot(data=mpg,aes(x=displ,y=hwy)) # aesthetics(미학)
qplot(mpg,wt,data=mtcars,color=factor(cyl),geom=c("point","line"))
# 단계1(layer1): 배경 설정하기.
# x축은 displ, y축은 hwy로 지정해 배경 생성
ggplot(data=mpg,aes(x=displ,y=hwy)) # aesthetics(미학)
# 단계2(layer2): 그래프 추가하기
# 배경에 산점도 추가
ggplot(data=mpg,aes(x=displ,y=hwy)) + geom_point()
# 단계3(layer3): 축범위를 조정하는 설정 추가하기.
# x축 범위값을 3~6으로 지정.
ggplot(data=mpg,aes(x=displ,y=hwy)) + geom_point() + xlim(3,6) + ylim(10,30)
# 단계2(layer2): 그래프 추가하기
# 배경에 산점도 추가
ggplot(data=mpg,aes(x=displ,y=hwy)) + geom_point()
# 단계3(layer3): 축범위를 조정하는 설정 추가하기.
# x축 범위값을 3~6으로 지정.
ggplot(data=mpg,aes(x=displ,y=hwy)) + geom_point() + xlim(3,6) + ylim(10,30)
# (1) 미적 요소 맵핑
p <- ggplot(diamonds, aes(carat,price,color=cut))
p + geom_point()
# (2) 기하학적 객체(geometric object:점/선/막대) 적용
p <- ggplot(mtcars, aes(mpg,wt,color=factor(cyl)))
p + geom_line()
p <- ggplot(mtcars, aes(mpg,wt,color=factor(cyl)))
p + geom_point()
# (3) 미적 요소 맵핑과 기하학적 객체 적용
p <- ggplot(diamonds, aes(price))
p + stat_bin(aes(fill=cut), geom="bar") # stat_bin():(aes():미적요소)+ ('geom=') : 기하학적 요소 + 기능 동시 적용.
# (3) 미적 요소 맵핑과 기하학적 객체 적용
p <- ggplot(diamonds, aes(price))
p + stat_bin(aes(fill=cut), geom="bar") # stat_bin():(aes():미적요소)+ ('geom=') : 기하학적 요소 + 기능 동시 적용.
p <- ggplot(diamonds, aes(price))
p + stat_bin(aes(fill=cut), geom="area")
p + stat_bin(aes(fill=cut), geom="area")
p + stat_bin(aes(color=cut,size=..density..), geom="point")
p + stat_bin(aes(fill=cut), geom="area")
p + stat_bin(aes(color=cut,size=..density..), geom="point")
# (4) 테마(Thema) 적용
p <- ggplot(diamonds, aes(carat,price,color=cut))
p <- p + geom_point() + ggtitle("다이아몬드 무게와 가격의 상관관계")
p
p + theme(
title=element_text(color="blue",size=25), #축제목
axis.title=element_text(size=14,face="bold"), # 축제목
axis.title.x=element_text(color="green"), # x축 제목
axis.title.y=element_text(color="red"), # y축 제목
axis.text=element_text(size="14"), # 축이름크기
axis.text.x=element_text(color="orange"), # x축이름(0~5)
axis.text.y=element_text(color="yellow"), # y축이름(0~15000)
legend.title = element_text(size=20,face="bold",color = "red"), # 범례
legend.position = "bottom",
legend.direction="horizontal")
p + theme(
title=element_text(color="blue",size=25), #축제목
axis.title=element_text(size=30,face="bold"), # 축제목
axis.title.x=element_text(color="green"), # x축 제목
axis.title.y=element_text(color="red"), # y축 제목
axis.text=element_text(size="14"), # 축이름크기
axis.text.x=element_text(color="orange"), # x축이름(0~5)
axis.text.y=element_text(color="yellow"), # y축이름(0~15000)
legend.title = element_text(size=20,face="bold",color = "red"), # 범례
legend.position = "bottom",
legend.direction="horizontal")
p <- ggplot(diamonds, aes(carat,price,color=cut))
p + geom_point()
# 가장 최근 그래프 저장
ggsave(file="D:/heaven_dev/workspaces/R/output/diamond_price.pdf")
ggsave(file="D:/heaven_dev/workspaces/R/output/diamond_price.jpg", dpi=72)
# 변수에 저장된 그래프 저장
p <- ggplot(diamonds, aes(clarity)) # 선명도
p <- p + geom_bar(aes(fill=cut), position="fill") # bar 추가
p
ggsave(file="D:/heaven_dev/workspaces/R/output/diamond_price.png",plot=p,width=10, height=5)
# 지도 관련 패키지 설치
library(ggplot2)  # ggplot2 패키지 로딩
install.packages("ggmap") # ggmap 패키지 설치
library(ggmap)
# 위도와 경도 중심으로 지도 시각화
# 실습: 서울을 중심으로 지도 시각화하기
# 단계 1: 서울 지역의 중심 좌표 설정
seoul <- c(left = 126.77, bottom = 37.40,
right = 127.17, top = 37.70)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 12, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 20, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 8, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 1000, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 1000, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 10000000, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 12, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 10, maptype = 'terrain')
ggmap(map)
# 단계 2: zoom, maptype으로 정적 지도 이미지 가져오기
map <- get_stamenmap(seoul, zoom = 14, maptype = 'terrain')
ggmap(map)
ggmap(map)
# 실습 : 2019년도 1월 대한민국 인구수를 기준으로 지역별 인구수 표시하기
# 단계 1: 데이터 셋 가져오기
pop <- read.csv(file.choose(), header = T)
View(pop)
library(stringr)
region <- pop$'지역명'
lon <- pop$LON
lat <- pop$LAT
tot_pop <- as.numeric(str_replace_all(pop$'총인구수', ',', ''))
df <- data.frame(region, lon, lat, tot_pop)
df
df <- df[1:17, ]
df
df <- data.frame(region, lon, lat, tot_pop)
df
df <- df[1:17, ]
df
# 단계 2: 정적 지도 이미지 가져오기
daegu <- c(left = 123.4423013, bottom = 32.8528306,
right = 131.601445, top = 38.8714354)
map <- get_stamenmap(daegu, zoom = 7, maptype = 'watercolor')
# 단계 3: 지도 시각화하기
layer1 <- ggmap(map)
layer1
# 단계 4: 포인트 추가
layer2 <- layer1 + geom_point(data = df,
aes(x = lon, y = lat,
color = factor(tot_pop),
size = factor(tot_pop)))
layer2
# 단계 5: 텍스트 추가
layer3 <- layer2 + geom_text(data = df,
aes(x = lon + 0.01, y = lat + 0.08,
label = region), size = 3)
layer3
# 단계 6: 크기를 지정하여 파일로 저장하기
ggsave("D:/heaven_dev/workspaces/R/output/pop201901.png", scale = 1, width = 10.24, height = 7.68)
# 1) 패키지 설치
#   - RJDBC 패키지를 사용하기 위해서는 우선 java를 설치해야 한다.
install.packages("rJava")
install.packages("DBI")
install.packages("RJDBC")
# 2) 패키지 로딩
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jre1.8.0_291')
library(DBI)
library(rJava)
library(RJDBC) # rJava에 의존적이다(rJava 먼저 로딩).
# 2) 패키지 로딩
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(DBI)
library(rJava)
library(RJDBC) # rJava에 의존적이다(rJava 먼저 로딩).
###  Oracle 11g Ex.
# driver
drv <- JDBC("oracle.jdbc.driver.OracleDriver",
"C:/oraclexe/app/oracle/product/11.2.0/server/jdbc/lib/ojdbc6.jar") # driver 이름, 경로
# db 연동(driver, url, id, pwd)
conn <- dbConnect(drv,"jdbc:oracle:thin:@//localhost:1521/xe","scott","tiger")
# (1) 모든 레코드 검색
query <- "select * from test_table"
dbGetQuery(conn, query)
# (2) 조건 검색 - 나이가 30세 이상인 레코드 조회
query <- "select * from test_table where age >= 30"
result <- dbGetQuery(conn, query)
result
str(result) # 'data.frame':	1 obs. of  4 variables:
View(result)
# (3) 정렬 조회 - 나이 컬럼을 기준으로 내림차순 정렬
query <- "select * from test_table order by age desc"
dbGetQuery(conn, query)
# (4) 레코드 삽입
query <- "insert into test_table values('kang', '1234','강감찬', 35)"
dbSendUpdate(conn, query)
# (5) 레코드 수정 : 데이터 '강감찬'의 나이를 40으로 수정.
query <- "update test_table set age=40 where name='강감찬'"
dbSendUpdate(conn, query)
query <- "select * from test_table"
dbGetQuery(conn, query) # DBI
# (5) 레코드 수정 : 데이터 '강감찬'의 나이를 40으로 수정.
query <- "update test_table set age=40 where name='강감찬'"
dbSendUpdate(conn, query)
query <- "select * from test_table"
dbGetQuery(conn, query) # DBI
# (6) 레코드 삭제 - 데이터 '홍길동' 레코드 삭제
query <- "delete from test_table where name='홍길동'"
dbSendUpdate(conn, query) # RJDBC
query <- "select * from test_table"
dbGetQuery(conn, query) # DBI
# (7) db 연결 종료
dbDisconnect(conn) #DBI
# (1) 패키지 설치 및 준비
#install.packages("KoNLP")
# - package ‘KoNLP’ is not available...
install.packages('https://cran.rstudio.com/bin/windows/contrib/3.6/sessioninfo_1.1.1.zip', repos = NULL)
install.packages("https://cran.rstudio.com/bin/windows/contrib/3.4/KoNLP_0.80.1.zip",repos = NULL)
install.packages("https://cran.rstudio.com/bin/windows/contrib/3.6/devtools_2.4.1.zip",repos = NULL)
# Sejong 설치: KoNLP와 의존성 있는 현재 버전의 한글 사전 Sejong 패키지 설치.
install.packages("Sejong")
install.packages(c("hash","tau","RSQLite","rJava"))
library(Sejong); library(hash); library(tau); library(RSQLite)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jre1.8.0_291')
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(rJava); library(devtools)
# Sejong 설치: KoNLP와 의존성 있는 현재 버전의 한글 사전 Sejong 패키지 설치.
install.packages("Sejong") # 한글 사전 기반
install.packages(c("hash","tau","RSQLite","rJava"))
library(Sejong); library(hash); library(tau); library(RSQLite)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(rJava); library(devtools)
library(KoNLP)
install.packages(c("wordcloud","tm"))
library(wordcloud); library(tm)
library(rJava); library(devtools)
library(rJava); library(devtools)
install.packages("devtools")
install.packages("devtools")
install.packages("fs")
library(Sejong); library(hash); library(tau); library(RSQLite)
# Sejong 설치: KoNLP와 의존성 있는 현재 버전의 한글 사전 Sejong 패키지 설치.
install.packages("Sejong") # 한글 사전 기반
install.packages(c("hash","tau","RSQLite","rJava"))
library(Sejong); library(hash); library(tau); library(RSQLite)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(rJava); library(devtools)
install.packages("devtools")
library(Sejong); library(hash); library(tau); library(RSQLite)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(rJava); library(devtools)
install.packages("devtools")
install.packages("devtools")
library(Sejong); library(hash); library(tau); library(RSQLite)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(rJava); library(devtools)
library(KoNLP)
install.packages("https://cran.rstudio.com/bin/windows/contrib/3.6/devtools_2.4.1.zip",repos = NULL)
# (1) 패키지 설치 및 준비
#install.packages("KoNLP")
# - package ‘KoNLP’ is not available... # 한국어가 가능하게 해주는 패키지
install.packages('https://cran.rstudio.com/bin/windows/contrib/3.6/sessioninfo_1.1.1.zip', repos = NULL)
install.packages("https://cran.rstudio.com/bin/windows/contrib/3.4/KoNLP_0.80.1.zip",repos = NULL)
library(Sejong); library(hash); library(tau); library(RSQLite)
Sys.setenv(JAVA_HOME='C:/Program Files/Java/jdk-11.0.16.1')
library(rJava); library(devtools)
library(KoNLP)
## 1.1 평균과 분산 그리고 표준편차
score1 <- c(85, 90, 93, 86, 82)
score2 <- c(100, 100, 50, 0, 0)#c(85, 90, 93, 46, 42)
score3 <- c(60, 60, 50, 40, 40)#c(100, 100, 54, 50, 52)
score10 <- c(100, 50, 30, 20, 20, 20, 10, NA)
mean(score10, na.rm = T)
# 평균
mean(score1)  # [1] 87.2 : 평균값
mean(score2)  # [1] 71.2 : 평균값
mean(score3)  # [1] 71.2 : 평균값
mean(score10, na.rm = T)
mean(score10)
# ex) 6, 6, 7, 8, 9, 10
num <- c(6, 6, 7, 8, 9, 10)
median(num) # 7.5(=(7+8)/2)
# 분산(Variance) : 편차 값을 제곱해서 마이너스 값을 플러스 값으로 바꾼 후 평균을 구하는 방법.
# ex) ((100-71.2)^2+(100-71.2)^2+(54-71.2)^2+(50-71.2)^2+(52-71.2)^2) / 5 = 554.56
score <- c(100, 100, 54, 50, 52)
mean(score) # 71.2
var(score)
sd(score)
