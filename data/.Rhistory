View(data.spss)
?memisc
#setwd("D:/heaven_dev/workspaces/R/data/")
data.spss <- as.data.set(spss.system.file('D:/heaven_dev/workspaces/R/data/drinking_water.sav', encoded = 'utf-8'))
data.spss
View(data.spss)
data.spss
View(data.spss)
# (2) 데이터프레임으로 변경
drinking_water <- data.spss[1:11]
drinking_water
drinking_water_df <- as.data.frame(drinking_water)
str(drinking_water_df)
View(drinking_water_df)
# (3)  요인수를 3개로 지정하여 요인분석 수행
result2 <- factanal(drinking_water_df, factors = 3, rotation = "varimax",
scores = "regression")
View(drinking_water_df)
# (3)  요인수를 3개로 지정하여 요인분석 수행
result2 <- factanal(drinking_water_df, factors = 3, rotation = "varimax",
scores = "regression")
result2
print(result2, cutoff=0.5)
# (3)  요인수를 3개로 지정하여 요인분석 수행
result2 <- factanal(drinking_water_df, factors = 3, rotation = "varimax",
scores = "regression") # regression 회귀(연속 변수에 대한 데이터 처리)
result2
print(result2, cutoff=0.5)
result2
# 1)  q4 칼럼 제외하여 데이터프레임 생성
dw_df <- drinking_water_df[-4] #제외시킴
str(dw_df)
dim(dw_df) # [1] 380  10
cor(dw_df)
class(dw_df)
names(dw_df) <- c('q1','q2','q3','q5','q6','q7','q8','q9','q10','q11')
dim(dw_df) # [1] 380  10
str(dw_df)
dim(dw_df) # [1] 380  10
cor(dw_df)
class(dw_df)
names(dw_df) <- c('q1','q2','q3','q5','q6','q7','q8','q9','q10','q11')
# 제품만족도 저장 데이터프레임
s <- data.frame(dw_df$q8, dw_df$q9, dw_df$q10, dw_df$q11)
# 제품친밀도 저장 데이터프레임
c <- data.frame(dw_df$q1, dw_df$q2, dw_df$q3)
# 제품적절성 저장 데이터프레임
p <- data.frame(dw_df$q5, dw_df$q6, dw_df$q7)
# 3) 요인별 산술평균 계산
satisfaction <- round( (s$dw_df.q8 + s$dw_df.q9 + s$dw_df.q10 + s$dw_df.q11) / ncol(s), 2)
closeness <- round( (c$dw_df.q1 + c$dw_df.q2 + c$dw_df.q3) / ncol(c), 2)
pertinence <- round( (p$dw_df.q5 + p$dw_df.q6 + p$dw_df.q7) / ncol(p), 2)
# 4) 상관관계 분석
drinking_water_factor_df <- data.frame(satisfaction, closeness, pertinence)
colnames(drinking_water_factor_df) <- c("제품만족도","제품친밀도","제품적절성")
cor(drinking_water_factor_df)
# 3) 요인별 (산술)평균 계산
satisfaction <- round( (s$dw_df.q8 + s$dw_df.q9 + s$dw_df.q10 + s$dw_df.q11) / ncol(s), 2)
closeness <- round( (c$dw_df.q1 + c$dw_df.q2 + c$dw_df.q3) / ncol(c), 2)
pertinence <- round( (p$dw_df.q5 + p$dw_df.q6 + p$dw_df.q7) / ncol(p), 2)
# 4) 상관관계 분석
drinking_water_factor_df <- data.frame(satisfaction, closeness, pertinence)
colnames(drinking_water_factor_df) <- c("제품만족도","제품친밀도","제품적절성")
cor(drinking_water_factor_df)
# [실습] 기술 통계량 구하기
result <- read.csv("D:/heaven_dev/workspaces/R/data/product.csv", header=TRUE)
# [실습] 기술 통계량 구하기
result <- read.csv("D:/heaven_dev/workspaces/R/data/product.csv", header=TRUE)
View(result)
head(result) # 친밀도 적절성 만족도(등간척도 - 5점 척도)
# 기술통계량
summary(result) # 요약통계량
sd(result$제품_친밀도); sd(result$제품_적절성); sd(result$제품_만족도)
# [실습] 기술 통계량 구하기
result <- read.csv("D:/heaven_dev/workspaces/R/data/product.csv", header=TRUE)
View(result)
head(result) # 친밀도 적절성 만족도(등간척도 - 5점 척도)
# 기술통계량
summary(result) # 요약통계량
sd(result$제품_친밀도); sd(result$제품_적절성); sd(result$제품_만족도)
# [실습] 기술 통계량 구하기
result <- read.csv("D:/heaven_dev/workspaces/R/data/product.csv", header=TRUE)
View(result)
head(result) # 친밀도 적절성 만족도(등간척도 - 5점 척도)
# 기술통계량
summary(result) # 요약통계량
sd(result$제품_친밀도); sd(result$제품_적절성); sd(result$제품_만족도)
# [실습] 상관계수(coefficient of correlation) : 두 변량 X,Y 사이의 상관관계 정도를 나타내는 수치(계수)
cor(result$제품_친밀도, result$제품_적절성) # 0.4992086 -> 다소 높은 양의 상관관계
cor(result$제품_친밀도, result$제품_만족도) # 0.467145 -> 다소 높은 양의 상관관계
cor(result)
# [실습] 방향성 있는 색상으로 표현
install.packages("corrgram")
library(corrgram)
corrgram(result) # 색상 적용 - 동일 색상으로 그룹화 표시
corrgram(result, upper.panel=panel.conf) # 수치(상관계수) 추가(위쪽)
corrgram(result, lower.panel=panel.conf) # 수치(상관계수) 추가(아래쪽)
corrgram(result) # 색상 적용 - 동일 색상으로 그룹화 표시
corrgram(result, upper.panel=panel.conf) # 수치(상관계수) 추가(위쪽)
corrgram(result, lower.panel=panel.conf) # 수치(상관계수) 추가(아래쪽)
# [실습] 차트에 밀도 곡선, 상관성, 유의확률(별표) 추가
install.packages("PerformanceAnalytics")
library(PerformanceAnalytics)
# 상관성,p값(*),정규분포 시각화 - 모수 검정 조건
chart.Correlation(result, histogram=, pch="+")
# [실습]  spearman : 서열척도 대상 상관계수
cor(result, method="spearman")
# 단계1: 데이터 셋 가져오기
data("AirPassengers") # 12년(1949~1961년)간 매월 항공기 탑승 승객 수를 기록한 시계열 자료.
str(AirPassengers) # Time-Series [1:144] from 1949 to 1961:
ts.plot(AirPassengers)
par(mfrow=c(1,2))
log <- diff(AirPassengers) # 차분 수행
plot(log) # 평균 정상화
plot(log) # 평균 정상화
log <- diff(log(AirPassengers)) # 로그+차분 수행
plot(log) # 분산 정상화
# 단계1: WWWusage 데이터 셋 가져오기 - R에서 기본 제공 데이터 셋으로 인터넷 사용 시간을 분 단위로 측정한 100개 vector로 구성된 시계열 자료.
data("WWWusage")
ts.plot(AirPassengers) # TimeSeries.plot = ts.plot
par(mfrow=c(1,2))
log <- diff(AirPassengers) # 차분 수행
plot(log) # 평균 정상화
log <- diff(log(AirPassengers)) # 로그+차분 수행
plot(log) # 분산 정상화
# 단계1: WWWusage 데이터 셋 가져오기 - R에서 기본 제공 데이터 셋으로 인터넷 사용 시간을 분 단위로 측정한 100개 vector(1차원배열)로 구성된 시계열 자료.
data("WWWusage")
str(WWWusage) # Time-Series [1:100] from 1 to 100:
WWWusage
X11()
ts.plot(WWWusage, type="l", col="red")
ts.plot(WWWusage, type="o", col="red")
# 단계1 : 데이터 셋 가져오기
data("EuStockMarkets") # 유럽(1991~1998년)의 주요 주식의 주가지수 일일 마감 가격.
head(EuStockMarkets) # DAX(독일) SMI(스위스) CAC(프랑스) FTSE(영국)
str(EuStockMarkets) # Time-Series [1:1860, 1:4]
# 단계2 : 데이터프레임으로 변환
EuStock <- data.frame(EuStockMarkets)
EuStock
head(EuStock)
plot(EuStock$DAX[1:1000], type = "l", col="red") # 선 그래프 시각화
# 단계1 : 데이터 셋 가져오기
data("EuStockMarkets") # 유럽(1991~1998년)의 주요 주식의 주가지수 일일 마감 가격.
head(EuStockMarkets) # DAX(독일) SMI(스위스) CAC(프랑스) FTSE(영국)
str(EuStockMarkets) # Time-Series [1:1860, 1:4]
# 단계2 : 데이터프레임으로 변환
EuStock <- data.frame(EuStockMarkets)
EuStock
head(EuStock)
plot(EuStock$DAX[1:1000], type = "l", col="red") # 선 그래프 시각화
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1000], EuStock$SMI[1:1000]), main="주가지수 추세선")
plot(EuStock$DAX[1:1000], type = "l", col="red") # 선 그래프 시각화
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1000], EuStock$SMI[1:1000]), main="주가지수 추세선")
ts.plot(WWWusage, type="l", col="red")
plot(EuStock$DAX[1:1000], type = "l", col="red") # 선 그래프 시각화
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1000], EuStock$SMI[1:1000]), main="주가지수 추세선")
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1800], EuStock$SMI[1:1800]), main="주가지수 추세선")
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1000], EuStock$SMI[1:1000]), main="주가지수 추세선")
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1800], EuStock$SMI[1:1800]), main="주가지수 추세선")
# 단계4 : 다중 시계열 데이터 추세선
plot.ts(cbind(EuStock$DAX[1:1800], EuStock$SMI[1:1800]), main="주가지수 추세선")
data <- c(45,56,45,43,69,75,58,59,66,64,62,65,
55,49,67,55,71,78,71,65,69,43,70,75,
56,56,65,55,82,85,75,77,77,69,79,89)
length(data) # 36
# 단계2 : 시계열자료 생성 : 시계열 자료 형식으로 객체 생성
tsdata <- ts(data, start = c(2016, 1), frequency = 12)
tsdata # 2016~2018
# 단계3 : 추세선 확인
par(mfrow=c(1,1))
ts.plot(tsdata) # plot(tsdata)와 동일함.
# 단계3 : 추세선 확인
par(mfrow=c(1,1))
ts.plot(tsdata) # plot(tsdata)와 동일함.
# 단계4 : 시계열 분해- stl():계절요소, 추세, 잔차 모두 제공.
plot(stl(tsdata, "periodic")) # periodic : 주기
ts.plot(tsdata) # plot(tsdata)와 동일함.
# 단계4 : 시계열 분해- stl():계절요소, 추세, 잔차 모두 제공.
plot(stl(tsdata, "periodic")) # periodic : 주기
# 단계4 : 시계열 분해- stl():계절요소, 추세, 잔차 모두 제공.
plot(stl(tsdata, "periodic")) # periodic : 주기
# 단계3 : 추세선 확인
par(mfrow=c(1,1))
ts.plot(tsdata) # plot(tsdata)와 동일함.
# 단계4 : 시계열 분해- stl():계절요소, 추세, 잔차 모두 제공.
plot(stl(tsdata, "periodic")) # periodic : 주기
# 단계5 : 시계열 분해와 변동 요인 제거
m <- decompose(tsdata) # decompose()함수 이용 시계열 분해
attributes(m) # 변수 보기
plot(m) # 추세요인, 계절요인, 불규칙 요인이 포함된 그래프.
plot(tsdata - m$seasonal) # 계절요인을 제거한 그래프.
attributes(m) # 변수 보기
plot(m) # 추세요인, 계절요인, 불규칙 요인이 포함된 그래프.
plot(tsdata - m$seasonal) # 계절요인을 제거한 그래프.
# 단계5 : 시계열 분해와 변동 요인 제거
m <- decompose(tsdata) # decompose()함수 이용 시계열 분해
attributes(m) # 변수 보기
plot(m) # 추세요인, 계절요인, 불규칙 요인이 포함된 그래프.
plot(tsdata - m$seasonal) # 계절요인을 제거한 그래프.
plot(m) # 추세요인, 계절요인, 불규칙 요인이 포함된 그래프.
plot(tsdata - m$seasonal) # 계절요인을 제거한 그래프.
plot(tsdata - m$trend) # 추세요인 제거 그래프
plot(tsdata - m$seasonal - m$trend) # 불규칙 요인만 출력.
# 단계1 : 시계열자료 생성
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
length(input) # 12
tsdata <- ts(input, start = c(2015, 2), frequency = 12) # Time Series
tsdata
acf(na.omit(tsdata), main="자기상관함수", col="red")
# 단계1 : 시계열자료 생성
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700) # 의미가 없다 # 데이터가 드러나게 할 수 있게 부각시키기 위해 임의로 만든 숫자
length(input) # 12
tsdata <- ts(input, start = c(2015, 2), frequency = 12) # Time Series
tsdata
acf(na.omit(tsdata), main="자기상관함수", col="red")
# 단계3 : 부분자기상관함수 시각화
pacf(na.omit(tsdata), main="부분자기상관함수", col="red")
acf(na.omit(tsdata), main="자기상관함수", col="red")
# 단계3 : 부분자기상관함수 시각화
pacf(na.omit(tsdata), main="부분자기상관함수", col="red")
acf(na.omit(tsdata), main="자기상관함수", col="red")
# 단계3 : 부분자기상관함수 시각화
pacf(na.omit(tsdata), main="부분자기상관함수", col="red")
# 단계1 : 시계열 자료 생성
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
# Time Series
tsdata <- ts(input, start = c(2015, 2), frequency = 12)
# 단계2 : 추세선 시각
plot(tsdata, type="l", col="red")
# 단계3 : 자기상관 함수 시각화
acf(na.omit(tsdata), main="자기상관함수", col="red")
# 단계4 : 차분 시각화
plot(diff(tsdata, differences=1))
# 단계3 : 자기상관 함수 시각화
acf(na.omit(tsdata), main="자기상관함수", col="red")
# 단계4 : 차분 시각화
plot(diff(tsdata, differences=1))
# 단계4 : 차분 시각화
plot(diff(tsdata, differences=1)) # 1 주기를 가지고 출력 # 평균 0을 기준으로 낮아지고 올라가고
# 단계1: 시계열  자료 생성
data <- c(45,56,45,43,69,75,58,59,66,64,62,65,
55,49,67,55,71,78,71,65,69,43,70,75,
56,56,65,55,82,85,75,77,77,69,79,89)
length(data) # 36
tsdata <- ts(data, start = c(2016, 1), frequency = 12)
tsdata
# 단계2 : 평활 관련 패키지 설치
install.packages("TTR")
library(TTR)
# 단계3 : 이동평균법으로 평활 및 시각화
par(mfrow=c(2,2))
plot(tsdata, main="원 시계열 자료") # 시계열 자료 시각화
plot(SMA(tsdata, n=1), main="1년 단위 이동평균법으로 평활")
plot(SMA(tsdata, n=2), main="2년 단위 이동평균법으로 평활")
plot(SMA(tsdata, n=3), main="3년 단위 이동평균법으로 평활")
# 단계1: 시계열  자료 생성
data <- c(45,56,45,43,69,75,58,59,66,64,62,65,
55,49,67,55,71,78,71,65,69,43,70,75,
56,56,65,55,82,85,75,77,77,69,79,89)
length(data) # 36
tsdata <- ts(data, start = c(2016, 1), frequency = 12)
tsdata
par(mfrow=c(1,1))
# 단계1: 시계열자료 특성분석
# (1) 데이터 준비
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
# (2) 시계열 객체 생성(12개월:2015년 2월 ~ 2016년 1월)
tsdata <- ts(input, start = c(2015, 2), frequency = 12)
tsdata
plot(tsdata, type="l", col='red')
# 단계1: 시계열자료 특성분석
# (1) 데이터 준비
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
# (2) 시계열 객체 생성(12개월:2015년 2월 ~ 2016년 1월)
tsdata <- ts(input, start = c(2015, 2), frequency = 12)
tsdata
plot(tsdata, type="l", col='red')
# 단계2:정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata)
plot(diff)
# 단계3: 모형 식별과 추정
install.packages('forecast')
# 단계1: 시계열자료 특성분석
# (1) 데이터 준비
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
# (2) 시계열 객체 생성(12개월:2015년 2월 ~ 2016년 1월)
tsdata <- ts(input, start = c(2015, 2), frequency = 12)
tsdata
# 단계1: 시계열자료 특성분석
# (1) 데이터 준비
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
# (2) 시계열 객체 생성(12개월:2015년 2월 ~ 2016년 1월)
tsdata <- ts(input, start = c(2015, 2), frequency = 12)
tsdata
plot(tsdata, type="l", col='red')
library(forecast)
arima <- auto.arima(tsdata) # 시계열 데이터 이용.
arima
# 단계2:정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata)
plot(diff)
plot(tsdata, type="l", col='red') # type='l'ine
# 단계2:정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata)
plot(diff)
plot(tsdata, type="l", col='red') # type='l'ine
# 단계2:정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata) # 차분
plot(diff)
# 단계1: 시계열자료 특성분석
# (1) 데이터 준비
input <- c(3180,3000,3200,3100,3300,3200,3400,3550,3200,3400,3300,3700)
# (2) 시계열 객체 생성(12개월:2015년 2월 ~ 2016년 1월)
tsdata <- ts(input, start = c(2015, 2), frequency = 12) # Time Series = ts
tsdata
plot(tsdata, type="l", col='red') # type='l'ine
# 단계2:정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata) # 차분
plot(diff)
library(forecast)
arima <- auto.arima(tsdata) # 시계열 데이터 이용. # ARIMA 모형을 통해
arima
model
# 단계4: 모형 생성
model <- arima(tsdata, order=c(1,1,0)) # order에 ARIMA 결과를 그대로 써주면 됨.
model
# 단계5: 모형 진단(모형 타당성 검정)
# (1) 자기상관함수에 의한 모형 진단
tsdiag(model)
# (2) Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag = 1, type = "Ljung")
# 단계5: 모형 진단(모형 타당성 검정)
# (1) 자기상관함수(AutoCorrelationFunction)에 의한 모형 진단 # 일정 간격을 찾아가는 것.
tsdiag(model) # TimeSeriesDialog
# (2) Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag = 1, type = "Ljung")
plot(diff)
# 단계4: 모형 생성(모델을 찾음)
model <- arima(tsdata, order=c(1,1,0)) # order에 ARIMA 결과를 그대로 써주면 됨.
model
# 단계5: 모형 진단(모형 타당성 검정)
# (1) 자기상관함수(AutoCorrelationFunction)에 의한 모형 진단 # 일정 간격을 찾아가는 것.
tsdiag(model) # TimeSeriesDialog
# 단계6 : 미래 예측(업무 적용)
fore <- forecast(model) # 향후 2년 예측
fore
par(mfrow=c(1,2))
plot(fore) # 향후 24개월 예측치 시각화
model2 <- forecast(model, h = 6) # 향후 6개월 예측치 시각화
plot(model2)
# 단계5: 모형 진단(모형 타당성 검정)
# (1) 자기상관함수(AutoCorrelationFunction)에 의한 모형 진단 # 일정 간격을 찾아가는 것.
tsdiag(model) # TimeSeriesDialog
# 단계6 : 미래 예측(업무 적용)
fore <- forecast(model) # 향후 2년 예측
fore
par(mfrow=c(1,2))
plot(fore) # 향후 24개월 예측치 시각화
# (2) Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag = 1, type = "Ljung") # 시차값을 지정해줌.
# 단계5: 모형 진단(모형 타당성 검정)
# (1) 자기상관함수(AutoCorrelationFunction)에 의한 모형 진단 # 일정 간격을 찾아가는 것.
tsdiag(model) # TimeSeriesDialog
# (2) Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag = 1, type = "Ljung") # 시차값을 지정해줌.
# 단계6 : 미래 예측(업무 적용)
fore <- forecast(model) # 향후 2년 예측
fore
x11()
model2 <- forecast(model, h = 6) # 향후 6개월 예측치 시각화
plot(model2)
# 단계5: 모형 진단(모형 타당성 검정)
# (1) 자기상관함수(AutoCorrelationFunction)에 의한 모형 진단 # 일정 간격을 찾아가는 것.
tsdiag(model) # TimeSeriesDialog
# (1) 데이터 준비
data <- c(55,56,45,43,69,75,58,59,66,64,62,65,
55,49,67,55,71,78,61,65,69,53,70,75,
56,56,65,55,68,80,65,67,77,69,79,82,
57,55,63,60,68,70,58,65,70,55,65,70)
length(data)# 48
# (2) 시계열자료 생성
tsdata <- ts(data, start=c(2016, 1),frequency=12)
#tsdata <- AirPassengers # 실제 data 적용.
tsdata
head(tsdata)
tail(tsdata)
# (3) 시계열요소분해 시각화
ts_feature <- stl(tsdata, s.window="periodic")
plot(ts_feature)
# 단계2 : 정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata)
plot(diff) # 차분 시각화
# 단계3 : 모형 식별과 추정
library(forecast)
ts_model2 <- auto.arima(tsdata)
ts_model2 # ARIMA(0,1,1)(1,1,0)[12] / ARIMA(2,1,1)(0,1,0)[12]
# 단계4 : 모형 생성
model <- arima(tsdata, c(0,1,1), seasonal = list(order = c(1,1,0)))
#model <- arima(tsdata, c(2,1,1), seasonal = list(order = c(0,1,0)))
model
# 단계5 : 모형 진단(모형 타당성 검정)
# (1) 자기상관함수에 의한 모형 진단
tsdiag(model)
# (2)Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag=1, type = "Ljung") # p-value = 0.5618 / p-value = 0.9879
# 단계6 : 미래 예측
par(mfrow=c(1,2))
fore <- forecast(model, h=24) # 2년 예측
plot(fore)
fore2 <- forecast(model, h=6) # 6개월 예측
plot(fore2)
# (1) 데이터 준비
data <- c(55,56,45,43,69,75,58,59,66,64,62,65,
55,49,67,55,71,78,61,65,69,53,70,75,
56,56,65,55,68,80,65,67,77,69,79,82,
57,55,63,60,68,70,58,65,70,55,65,70)
# 단계4 : 시계열 분해- stl():계절요소, 추세, 잔차 모두 제공.
plot(stl(tsdata, "periodic")) # periodic : 주기
# 단계5 : 시계열 분해와 변동 요인 제거
m <- decompose(tsdata) # decompose()함수 이용 시계열 분해
attributes(m) # 변수 보기
plot(m) # 추세요인, 계절요인, 불규칙 요인이 포함된 그래프.
# (2) 시계열자료 생성
tsdata <- ts(data, start=c(2016, 1),frequency=12)
#tsdata <- AirPassengers # 실제 data 적용.
tsdata
head(tsdata)
tail(tsdata)
# (3) 시계열요소분해 시각화
ts_feature <- stl(tsdata, s.window="periodic")
plot(ts_feature)
# 단계2 : 정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata)
plot(diff) # 차분 시각화
# (3) 시계열요소분해 시각화
ts_feature <- stl(tsdata, s.window="periodic") # or Decompose함수를 사용
plot(ts_feature)
# 단계2 : 정상성시계열 변환
par(mfrow=c(1,2))
ts.plot(tsdata)
diff <- diff(tsdata)
plot(diff) # 차분 시각화
# 단계3 : 모형 식별과 추정
library(forecast)
ts_model2 <- auto.arima(tsdata)
ts_model2 # ARIMA(0,1,1)(1,1,0)[12] / ARIMA(2,1,1)(0,1,0)[12]
ts_model2 <- auto.arima(tsdata)
ts_model2 # ARIMA(0,1,1)(1,1,0)[12] / ARIMA(2,1,1)(0,1,0)[12]
# 단계4 : 모형 생성
model <- arima(tsdata, c(0,1,1), seasonal = list(order = c(1,1,0)))
#model <- arima(tsdata, c(2,1,1), seasonal = list(order = c(0,1,0)))
model
# 단계5 : 모형 진단(모형 타당성 검정)
# (1) 자기상관함수에 의한 모형 진단
tsdiag(model)
# (2)Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag=1, type = "Ljung") # p-value = 0.5618 / p-value = 0.9879
# (2)Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag=1, type = "Ljung") # p-value = 0.5618 / p-value = 0.9879
# 단계6 : 미래 예측
par(mfrow=c(1,2))
fore <- forecast(model, h=24) # 2년 예측
plot(fore)
fore2 <- forecast(model, h=6) # 6개월 예측
plot(fore2)
# 단계5 : 모형 진단(모형 타당성 검정)
# (1) 자기상관함수에 의한 모형 진단
tsdiag(model)
# (2)Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag=1, type = "Ljung") # p-value = 0.5618 / p-value = 0.9879
# 단계6 : 미래 예측
par(mfrow=c(1,2))
fore <- forecast(model, h=24) # 2년 예측
plot(fore)
fore2 <- forecast(model, h=6) # 6개월 예측
plot(fore2)
plot(diff) # 차분 시각화
ts_model2 <- auto.arima(tsdata) # 데이터에 대한 모형을 식별과 추정하도록 요청해주면 됨
ts_model2 # ARIMA(0,1,1)(1,1,0)[12] / ARIMA(2,1,1)(0,1,0)[12]
# 단계4 : 모형 생성
model <- arima(tsdata, c(0,1,1), seasonal = list(order = c(1,1,0)))
#model <- arima(tsdata, c(2,1,1), seasonal = list(order = c(0,1,0)))
model
# (2)Box-Ljung에 의한 잔차항 모형 진단
Box.test(model$residuals, lag=1, type = "Ljung") # p-value = 0.5618 / p-value = 0.9879
# 단계4 : 모형 생성
model <- arima(tsdata, c(0,1,1), seasonal = list(order = c(1,1,0)))
#model <- arima(tsdata, c(2,1,1), seasonal = list(order = c(0,1,0)))
model
# 단계5 : 모형 진단(모형 타당성 검정)
# (1) 자기상관함수에 의한 모형 진단
tsdiag(model)
